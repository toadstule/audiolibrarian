#!python

"""
PYTHONPATH=$(pwd) scripts/audiolibrarian /media/BlackBox/Music/flac/some_file

"""
#  Copyright (c) 2020 Stephen Jibson
#
#  This file is part of audiolibrarian.
#
#  audiolibrarian is free software: you can redistribute it and/or modify it under the terms of the
#  GNU General Public License as published by the Free Software Foundation, either version 3 of the
#  License, or (at your option) any later version.
#
#  audiolibrarian is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
#  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#  the GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along with audiolibrarian.
#  If not, see <https://www.gnu.org/licenses/>.
#

import argparse
import logging
import sys
from pathlib import Path

from audiolibrarian import check_deps, commands

log = logging.getLogger("audiolibrarian")


# noinspection PyProtectedMember
def parse_args():
    parser = argparse.ArgumentParser(description="Audio Librarian")

    # global options
    parser.add_argument(
        "--log-level",
        "-l",
        choices=("CRITICAL", "ERROR", "WARNING", "INFO", "DEBUG"),
        default="ERROR",
        help="log level (default: ERROR)",
    )

    # add sub-commands and args for sub_commands
    subparsers = parser.add_subparsers(title="commands", dest="command")
    for cmd_ in commands:
        # this is a total hack because argparse won't allow you to add an already
        # existing ArgumentParser as a sub-parser.
        if cmd_.parser:
            cmd_.parser.prog = f"{subparsers._prog_prefix} {cmd_.command}"
            subparsers._choices_actions.append(
                subparsers._ChoicesPseudoAction(cmd_.command, (), cmd_.help)
            )
            subparsers._name_parser_map[cmd_.command] = cmd_.parser

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()

    logging.basicConfig(level=args.log_level)
    logging.captureWarnings(True)
    log.info(f"ARGS: {args}")

    if not check_deps():
        sys.exit(1)

    for cmd in commands:
        if args.command == cmd.command:
            if not cmd.validate_args(args):
                sys.exit(2)
            cmd(args)
            break
    if args.log_level == logging.DEBUG:
        print(Path("/proc/self/status").read_text())
